# 第8节 Redis

Redis自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型。

## Redis常用数据类型

Redis用到的所有主要数据结构：简单动态字符串（SDS），双端链表，字典，压缩列表、整数集合等等。基于这些数据结构创建了一个对象系统。包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型。

Redis最为常用的数据类型主要有以下五种：

- String 字符串对象
- Hash 哈希对象
- List 列表对象
- Set 集合对象
- Sorted set 有序集合对象

Redis在自己的对象系统中构建了一个**引用计数技术**实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。



Redis服务器默认会创建16个数据库。Redis客户端的目标数据库为0号数据库。



通过EXPIRE命令或PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL）

TTL命令和PTTL命令接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间。



PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。


## Redis的过期策略和内存淘汰机制
过期键删除策略：

1. 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器 在键的过期时间来临时，立刻执行对键的删除操作。
2. 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键。
3. 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。

Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次。

**Redis服务器实际使用的是惰性删除和定期删除两种策略。**

但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，怎么办？

答案是：走内存淘汰机制。

**内存淘汰机制**
如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：
　　noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，**采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略**。
　　allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
　　allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧
　　volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）
　　volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
　　volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除



Redis提供了RDB持久化功能，可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。



AOF（Append Only File）持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。

服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。



Redis服务器是一个事件驱动程序，需处理以下两类事件：

文件事件（file event）

时间事件（time event）



Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器。

通过使用由I/O多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。



PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式。



SLAVEOF命令是一个异步命令，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复值指令已经被接收，而实际的复制工作将在OK返回之后才真正开始执行。



Sentinel（哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的，Sentinel系统可用监视任意多个主服务器。

Sentinel本质上只是一个运行在特殊模式下的Redis服务器。

Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令。



Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。



连接各个节点的工作可以使用CLUSTERMEET命令来完成



Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。



Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表。链表里面记录了所有订阅这个频道的客户端。所有模式的订阅关系都保存在服务器状态的pubsub_patterms属性里面。



Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交（commit）给服务器执行。

每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里面。事务状态包含一个事务队列，以及一个已入队命令的计数器。事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息。

WATCH命令是一个乐观锁（optimistic locking），它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话服务器将拒绝执行事务并向客户端返回空。



watched_keys字典，根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务。



Redis不支持事务回滚机制（rollback）。



Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。



基于Redis实现分布式锁 SETNX

